# Processor

## Введение

Эта программа - виртуальная машина, в которой симулируется работа процессора. Она состоит из трёх частей: ассемблера, машины и дизассемблера. Рассмотрим каждую из этих частей поподробнее.

## Assembler

Эта часть переводит язык ассемблера в машинный код. Для этого используется построчное считывание команд. Вот перечень правил, которых стоит придерживаться при написании кода на этом языке:

1. Одной строке соответствует одна команда. Пустые строки разрешены.

2. Однострочные комментарии обозначаются знаком ';' (точка с запятой), после этого символа все остальные, вплоть до следующей строки, игнорируются.

3. Имена меток начинаются с новой строки (символы табуляции не игнорируются) и заканчиваются символом ':' (он не входит в её имя). Они используются командами перехода (будут перечислены далее).

4. Вот полный список команд языка:

```
push - положить что-либо в стек. Возможные варианты:
push 1       - число
push rax     - из регистра
push [rax]   - из ячейки памяти
push [rax+1] - из ячейки памяти

pop - достать число из стека. Возможные варианты:
pop         - проигнорировать значение числа
pop rax     - положить число в регистр
pop [rax]   - положить число в ячейку памяти
pop [rax+1] - положить число в ячейку памяти
```

Отметим, что эти две команды кодируются по-особенному: в первых трёх битах лежит информация, какой из этих вариантов реализуется.

```
add  - сложить два "верхних" числа на стеке
mul  - умножить два "верхних" числа на стеке
sub  - вычесть из предпоследнего числа на стеке последнее
div  - разделить предпоследнее число на стеке на последнее
sin  - вычислить значение синуса для числа на стеке
cos  - вычислить значение косинуса для числа на стеке
sqrt - вычислить значение корня для числа на стеке
neg  - поменять знак числа
out  - вывести число на экран
in   - попросить ввести число
dumb - распечатка дампа стека
hlt  - завершить работу процессора
scr start width hight  - создаёт в оперативной памяти, начиная со start, буфер width * hight, который трактуется как видеопамять для консоли.
upd - обновление экрана (вывод буфера, созданного scr)
rnd - округление числа на стеке
pow - возведение числа, предпоследнего на стеке, в степень, равную последнему
```

Обратите внимание, что команды, работающие с числами, не сохраняют числа, взятые из стека. Это же касается и команд условного перехода.

Команды перехода:

```
jmp  - безусловный переход. Может быть несколько вариантов:
jmp 25    - переход на 25-ый байт
jmp :name - переход на метку с именем name
jmp :25   - переход на метку с именем 25 (работает быстрее предыдущего варианта)
```

Все три варианта с точки зрения машинного кода неразличимы. Дальнейшие команды имеют такие же варианты аргументов:

```
call - безусловный переход, в стек кладётся адрес возврата
ret  - безусловный переход по адресу, лежащему на стеке
Следующие команды сравнивают предпоследнее число (x) с последним (y). Прыжки происходят в следующих случаях:
ja  - x > y
jae - x >= y
jb  - x < y
jbe - x <= y
je  - x == y
jne - x != y
```

Обратите внимание, что стек для чисел и адресов един, поэтому за корректностью места возврата должен следить программист!

## Machine

Эта программа исполняет побайтово код, сгенерированный ассемблером. Отметим, что каждая команда перед распознанием маскируется, чтобы ```push``` и ```pop``` распознавались вне зависимости от их варианта.

## Disassembler

Перевод из байт-кода в код ассемблера. Все команды условного перехода трактуются первым способом.

## Define Files

Теперь стоит обратить внимание на особенность построения этих программ - единая система команд. Для этого написан файл ```Commands.h```, в котором все команды представлены в едином формате:

```DEV_CMD(name, number, cmd)```
```DEV_CMD_ARG(name, number, cmd)```

, где:

```name``` - строка с именем ассемблерной команды

```number``` - номер команды в байт-коде

```cmd``` - действия, которые нужно выполнить при исполнении команды

Этот файл подставляется с помощью ```#define``` и ```#include``` во все программы. Но из-за различий в ```#define```, подставляемый код делает разные действия в разных программах. К сожалению, здесь эта система реализована не лучшим образом, поэтому автор не может порекомендовать использовать её в своих проектах.

## Спасибо за внимание!
